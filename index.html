<!doctype html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infosk√¶rm Al-Irchad (Optimized)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Tajawal:wght@400;600;700&display=swap');

  :root{
    --bg: linear-gradient(135deg,#e8f0ff,#f9fbff);
    --fg:#1e293b;
    --overlay:rgba(255,255,255,0.9);
    --accent:#007bff;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:'Tajawal',system-ui,sans-serif;color:var(--fg);overflow:hidden}
  .stage{position:relative;width:100%;height:100%}
  /* Slide basics */
  .slide{position:absolute;inset:0;display:flex;justify-content:center;align-items:center;padding:4%;opacity:0;pointer-events:none;transition:opacity .7s ease,transform .7s ease}
  .slide.active{opacity:1;pointer-events:auto}
  .text{font-weight:700;font-size:clamp(26px,4.6vw,64px);text-align:center;max-width:1400px}
  /* single reusable background image */
  #bgImg{position:absolute;inset:0;margin:auto;max-width:90%;max-height:90%;object-fit:contain;border-radius:12px;transition:opacity .8s ease,transform .8s ease;opacity:0}
  #bgImg.show{opacity:1;transform:scale(1)}
  /* small UI boxes */
  .datetime{position:absolute;top:14px;right:18px;background:var(--overlay);padding:10px 14px;border-radius:12px;backdrop-filter:blur(4px);text-align:right;box-shadow:0 3px 10px rgba(0,0,0,0.12)}
  .datetime #dateText{font-size:18px;font-weight:600}
  .datetime #timeText{font-size:28px;font-weight:700}
  .logo{position:absolute;top:12px;left:12px;background:var(--overlay);padding:8px;border-radius:12px;box-shadow:0 3px 8px rgba(0,0,0,0.12)}
  .logo img{height:56px;display:block}
  .schedule{position:absolute;right:18px;bottom:16px;background:var(--overlay);padding:8px;border-radius:10px;backdrop-filter:blur(4px);box-shadow:0 3px 10px rgba(0,0,0,0.12);font-size:14px}
.vikarskema {
  position: fixed;               /* stay in place on screen */
  top: 50%;                      /* center vertically */
  left: 50%;                     /* center horizontally */
  transform: translate(-50%, -50%);
  width: 85%;                    /* bigger width */
  max-width: 1400px;
  max-height: 80vh;              /* slightly bigger height */
  background: var(--overlay);
  padding: 24px;                 /* more padding */
  border-radius: 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
  font-size: 20px;               /* bigger text for table */
  z-index: 9999;                 /* above everything else */
}

.vikarskema table {
  width: 100%;
  border-collapse: collapse;
  font-size: 22px;               /* bigger table text */
}

.vikarskema th, .vikarskema td {
  padding: 10px;                 /* bigger cells */
  border: 1px solid rgba(0,0,0,0.12);
  text-align: center;
}

.vikarskema th {
  background: var(--accent);
  color: #fff;
  font-weight: 700;
  font-size: 26px;               /* bigger header */
}
  .infoBox{position:fixed;left:16px;bottom:22px;background:var(--overlay);padding:12px 16px;border-radius:12px;backdrop-filter:blur(4px);box-shadow:0 4px 12px rgba(0,0,0,0.12);font-weight:600;max-width:40%;display:inline-block}
 
 /* banners */
  .banner{position:fixed;top:18px;left:50%;transform:translateX(-50%);padding:14px 28px;border-radius:14px;font-weight:800;color:#fff;display:none;z-index:9999; font-size: 36px}
  .banner.active{display:block}
  .banner.red{background:#d93025}
  /* reduce heavy visual effects ‚Äî keep it smooth */
  img.small{max-height:70px;object-fit:contain;border-radius:8px}
  /* accessibility */
  @media (max-width:900px){ .vikarskema{max-width:90%;left:6px;bottom:120px} .infoBox{max-width:90%;left:6px;bottom:80px} .schedule{right:6px;bottom:80px} }

 #vikarTitle {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 48px;
    font-weight: bold;
    color: white;
    text-shadow: 0 0 12px rgba(0,0,0,0.6);
    z-index: 9999; /* Above EVERYTHING */
    pointer-events: none;
  }
</style>
</style>
</head>
<body>
 


 <div class="stage" id="stage">
    <div class="slide active" id="welcomeSlide"><div class="text">üëã Velkommen til Al-Irchad Skolen</div></div>
    <div class="slide" id="vikarSlide"><div id="vikarTitle">Vikarskema</div><div class="vikarskema" id="vikarskemaContent">Indl√¶ser vikarskema‚Ä¶</div></div>
    <!-- reusable background image -->
    <img id="bgImg" alt="slide image">
  </div>

  <div class="logo"><img src="https://www.al-irchadskolen.dk/wp-content/uploads/2024/03/images.png" alt="logo"></div>
  <div class="datetime"><div id="dateText">‚Äì</div><div id="timeText">‚Äì</div></div>
  <div class="schedule" id="schedule">‚Äì</div>
  <div class="infoBox" id="infoBox">Indl√¶ser‚Ä¶</div>

  <div class="banner red" id="morgensamling">‚è∞ Det er tid til morgensamling!</div>
  <div class="banner red" id="gardvagt">üîî G√•rdvagt!</div>

  <!-- audio elements: use relative paths or host files (file:// often blocked) -->
  <audio id="morgensamlingSound" preload="auto" src="sounds/morgensamling.mp3"></audio>
  <audio id="gardvagtSound" preload="auto" src="sounds/gardvagt.mp3"></audio>

<script>
/* ===========================
   CONFIGURATION (tweak here)
   =========================== */
const CONFIG = {
  TICK_INTERVAL_MS: 1000,             // internal tick
  INFO_ROTATE_SEC: 20,                // infoBox rotate
  VIKAR_FETCH_SEC: 90,                // fetch vikar sheet
  CUSTOM_FETCH_SEC: 90,               // fetch images sheet
  WEATHER_FETCH_MIN: 30,              // minutes between weather fetch
  AUTO_RELOAD_HOURS: 6,               // auto reload to recover memory leaks
  SLIDE_WELCOME_SEC: 5,
  SLIDE_IMAGE_SEC: 6,
  SLIDE_VIKAR_SEC: 30
};

/* ===========================
   STATE & DOM references
   =========================== */
const dateEl = document.getElementById('dateText');
const timeEl = document.getElementById('timeText');
const infoBox = document.getElementById('infoBox');
const bgImg = document.getElementById('bgImg');
const welcomeSlide = document.getElementById('welcomeSlide');
const vikarSlide = document.getElementById('vikarSlide');
const stageSlides = [welcomeSlide, vikarSlide];
const scheduleEl = document.getElementById('schedule');
const vikarskemaContent = document.getElementById('vikarskemaContent');
const morgensamlingBanner = document.getElementById('morgensamling');
const gardvagtBanner = document.getElementById('gardvagt');
const morgensamlingSound = document.getElementById('morgensamlingSound');
const gardvagtSound = document.getElementById('gardvagtSound');

/* ===========================
   UTIL: safe fetch with timeout
   =========================== */
async function safeFetch(url, opts = {}, timeout = 8000) {
  try {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const r = await fetch(url, { signal: controller.signal, ...opts });
    clearTimeout(id);
    if(!r.ok) throw new Error('HTTP ' + r.status);
    return await r.json();
  } catch (e) {
    console.warn('fetch failed', url, e);
    throw e;
  }
}

/* ===========================
   CLOCK (runs each second)
   =========================== */
function updateDateTime(now = new Date()) {
  dateEl.textContent = now.toLocaleDateString('da-DK', { weekday:'long', year:'numeric', month:'long', day:'numeric' });
  timeEl.textContent = now.toLocaleTimeString('da-DK', { hour:'2-digit', minute:'2-digit', second:'2-digit' });
}

/* ===========================
   SIMPLE SCHEDULER
   We run one tick every CONFIG.TICK_INTERVAL_MS
   and only run tasks when their 'due' time arrived.
   This reduces setInterval proliferation.
   =========================== */
const tasks = [];
function schedule(name, intervalMs, fn, immediate=true) {
  tasks.push({name, intervalMs, fn, due: immediate ? 0 : Date.now() + intervalMs, failureCount:0});
}

/* runner */
setInterval(async () => {
  const now = Date.now();
  for (const t of tasks) {
    if (now >= t.due) {
      try {
        await t.fn();
        t.failureCount = 0;
        t.due = now + t.intervalMs;
      } catch (err) {
        t.failureCount++;
        // exponential backoff up to 10x
        const backoff = Math.min(10, Math.pow(2, Math.min(t.failureCount,6)));
        t.due = now + (t.intervalMs * backoff);
        console.warn(`Task ${t.name} failed. Backing off x${backoff}`, err);
      }
    }
  }
}, CONFIG.TICK_INTERVAL_MS);

/* ===========================
   VIKARSKEMA (fetch & render)
   =========================== */
const VIKAR_URL = 'https://script.google.com/macros/s/AKfycbyQ5e7UHSmfxdAGJgfAo7mHHnH37ktEIHO0QPEP7TxOlSZ0Tb5lwTAO_9MBtqZG4vSvWw/exec';

async function fetchVikarskema() {
  const data = await safeFetch(VIKAR_URL, {}, 9000);
  // Expecting { headers: [...], rows: [ [...], ... ] }
  const headers = data.headers || ['Tid','A','B','C','D','E'];
  const rows = data.rows || [];
  renderVikarskema(headers, rows);
}

function renderVikarskema(headers, rows) {
  // small safe renderer
  let html = '<table><thead><tr>' + headers.map(h => `<th>${escapeHTML(h)}</th>`).join('') + '</tr></thead><tbody>';
  for (const r of rows) {
    html += '<tr>' + r.map(cell => {
      if (typeof cell === 'string' && cell.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
        return `<td><img class="small" src="${escapeAttr(cell)}" alt=""></td>`;
      } else {
        return `<td>${escapeHTML(String(cell || ''))}</td>`;
      }
    }).join('') + '</tr>';
  }
  html += '</tbody></table>';
  vikarskemaContent.innerHTML = html;
  highlightCurrentVikarskemaRow(); // immediate highlight
}

/* highlight current row by parsing first column times (like "09:10-09:20") */
function highlightCurrentVikarskemaRow() {
  try {
    const now = new Date();
    const rows = vikarskemaContent.querySelectorAll('tbody tr');
    rows.forEach(r => r.classList.remove('current'));
    rows.forEach(row => {
      const first = row.cells[0]?.textContent?.trim();
      if (!first) return;
      const parts = first.split('-').map(s => s.trim());
      if (parts.length < 1) return;
      const start = parts[0].split(':').map(Number);
      const end = (parts[1] || parts[0]).split(':').map(Number);
      const startMin = (start[0]||0)*60 + (start[1]||0);
      const endMin = (end[0]||0)*60 + (end[1]||0);
      const nowMin = now.getHours()*60 + now.getMinutes();
      if (nowMin >= startMin && nowMin < endMin) row.classList.add('current');
    });
  } catch(e) { /* silent */ }
}

/* ===========================
   SCHEDULE BOX (offline schedule object)
   =========================== */
const schedules = {
  1:{title:"G√•rdvagtskema", rows:[["9:10-09:20","PP","EY","JL","TN","MA"],["10:50-11:15","PP","NC","LC","JD","MA"],["12:35-12:50","PP","JL","KP","JD","SR"]]},
  2:{title:"G√•rdvagtskema", rows:[["9:10-09:20","NC","EY","EK","TN","IR"],["10:50-11:15","MD","EY","EK","TN","IR"],["12:35-12:50","MD","JL","EK","IH","SR"]]},
  3:{title:"G√•rdvagtskema", rows:[["9:10-09:20","NC","AD","SJ","LL","JL"],["10:50-11:15","ZA","AD","SJ","IH","LL"],["12:35-12:50","ZA","AD","SJ","AFH","LL"]]},
  4:{title:"G√•rdvagtskema", rows:[["9:10-09:20","NC","EY","MB","AFH","MT"],["10:50-11:15","HR","LC","MP","MT","SR"],["12:35-12:50","MD","HR","MP","IH","JD"]]},
  5:{title:"G√•rdvagtskema", rows:[["9:10-09:20","AD","MB","KP","MT","MA"],["10:50-11:15","MA","MB","MP","AFH","MT"]]}
};

function renderSchedule() {
  const today = new Date().getDay();
  const sch = schedules[today];
  if (!sch) { scheduleEl.innerHTML = ''; return; }
  let html = '<table><thead><tr><th colspan="6">' + escapeHTML(sch.title) + '</th></tr><tr><th>Pause</th><th>SG1</th><th>SG2</th><th>MB3</th><th>SG4</th><th>G5</th></tr></thead><tbody>';
  sch.rows.forEach(r => {
    html += '<tr>' + r.map(c => `<td>${escapeHTML(c)}</td>`).join('') + '</tr>';
  });
  html += '</tbody></table>';
  scheduleEl.innerHTML = html;
}

/* ===========================
   INFO BOX (combines computed items + sheet rows)
   rotate periodically
   =========================== */
const infoItems = [
  () => `‚òÄÔ∏è Vejr i Helsing√∏r: ${currentWeather.desc}, ${currentWeather.temp}`
];
let sheetRows = [["Ingen data"]];
let infoIndex = 0;

async function fetchInfoSheet() {
  // replace with your sheet webhook that returns JSON rows
  const INFO_SHEET = 'https://script.google.com/macros/s/AKfycbwPfXNL6-gcGdxDWd8FXeBej4mJFnutlgApxtzPelYwk2W_L1MoQS8kYpHunsB17PYutA/exec';
  const data = await safeFetch(INFO_SHEET, {}, 9000);
  sheetRows = (data.sheets && data.sheets[0]?.rows) || data.rows || sheetRows;
  if (!Array.isArray(sheetRows) || sheetRows.length === 0) sheetRows = [["Ingen data"]];
}

function rotateInfo() {
  let text;
  if (infoIndex < infoItems.length) {
    const it = infoItems[infoIndex];
    text = (typeof it === 'function') ? it() : String(it);
  } else {
    const row = sheetRows[(infoIndex - infoItems.length) % sheetRows.length];
    text = Array.isArray(row) ? row.join(' | ') : String(row);
  }
  infoBox.textContent = text;
  infoIndex = (infoIndex + 1) % (infoItems.length + sheetRows.length);
}

/* ===========================
   WEATHER (uses open-meteo)
   =========================== */
let currentWeather = { desc:'-', temp:'-' };
async function fetchWeather() {
  // Helsing√∏r lat/lon used previously; safe open-meteo endpoint
  const url = 'https://api.open-meteo.com/v1/forecast?latitude=56.03&longitude=12.59&current_weather=true&temperature_unit=celsius';
  const data = await safeFetch(url, {}, 9000);
  currentWeather.temp = Math.round(data.current_weather.temperature) + "¬∞C";
  currentWeather.desc = `Vind ${data.current_weather.windspeed} km/t`;
}

/* ===========================
   CUSTOM IMAGES SLIDES (Google sheet webhook)
   lightweight: only keep small array of URLs, preload next one only
   =========================== */
const CUSTOM_WEBHOOK = 'https://script.google.com/macros/s/AKfycbwic1LHHatZ_tAehcE4Hvb-QV-m_ua0k0Hedgre_URMhm8Sva2Bf3QltFN9tOCiJJP1Xw/exec';
let customImages = [];
let customIndex = 0;

async function fetchCustomImages() {
  const data = await safeFetch(CUSTOM_WEBHOOK, {}, 9000);
  let rows = Array.isArray(data) ? data : (data.rows || data.sheets?.[0]?.rows || []);
  // pick image URLs from rows
  const urls = [];
  for (const r of rows) {
    if (Array.isArray(r)) {
      for (const c of r) if (typeof c === 'string' && c.match(/\.(jpg|jpeg|png|gif|webp)$/i)) urls.push(c);
    } else if (r && typeof r.img === 'string') urls.push(r.img);
  }
  customImages = urls;
  customIndex = 0;
}

function showSlideByName(name) {
  stageSlides.forEach(s => s.classList.toggle('active', s.id === name));
}

/* show background image (reuses single img element) */
let lastBgUrl = null;
function showBackgroundImage(url) {
  if (!url) {
    bgImg.classList.remove('show');
    setTimeout(()=>{ bgImg.src=''; }, 900); // clear after fade
    lastBgUrl = null;
    return;
  }
  if (url === lastBgUrl) { bgImg.classList.add('show'); return; }
  // preload then swap to reduce flicker
  const pre = new Image();
  pre.onload = () => {
    bgImg.src = pre.src;
    // small fade in
    requestAnimationFrame(()=> bgImg.classList.add('show'));
    lastBgUrl = pre.src;
  };
  pre.onerror = () => { console.warn('bg preload failed', url); };
  pre.src = url;
}

/* cycle function: minimal CPU usage (uses task schedule instead of constant polling) */
let slideState = { phase: 'welcome', stepUntil: 0 };

async function runSlidesOnce() {
  // This function determines which slide to show next and for how long.
  const now = Date.now();

  if (now < slideState.stepUntil) return; // wait until this step ends

  // If there are images, sequence: welcome -> batch of images -> vikar -> repeat
  if (customImages.length === 0) {
    // simple alternate welcome (5s) and vikar(30s)
    if (slideState.phase === 'welcome' || !slideState.phase) {
      showSlideByName('welcomeSlide');
      showBackgroundImage(null);
      slideState.phase = 'vikar';
      slideState.stepUntil = now + CONFIG.SLIDE_WELCOME_SEC*1000;
    } else {
      showSlideByName('vikarSlide');
      showBackgroundImage(null);
      slideState.phase = 'welcome';
      slideState.stepUntil = now + CONFIG.SLIDE_VIKAR_SEC*1000;
    }
    return;
  }

  // With images:
  if (!slideState.phase || slideState.phase === 'end') {
    // start with welcome
    showSlideByName('welcomeSlide');
    showBackgroundImage(null);
    slideState.phase = 'images';
    slideState.stepUntil = now + CONFIG.SLIDE_WELCOME_SEC*1000;
    customIndex = 0;
    return;
  }

  if (slideState.phase === 'images') {
    // show next image (single image at center)
    const url = customImages[customIndex % customImages.length];
    showSlideByName(null); // hide slides so bg image is main
    showBackgroundImage(url);
    slideState.phase = 'images';
    slideState.stepUntil = now + CONFIG.SLIDE_IMAGE_SEC*1000;
    customIndex++;
    // after showing N images show vikar
    if ((customIndex % 3) === 0) { slideState.phase = 'vikar'; slideState.stepUntil = now + CONFIG.SLIDE_IMAGE_SEC*1000; }
    return;
  }

  if (slideState.phase === 'vikar') {
    showSlideByName('vikarSlide');
    showBackgroundImage(null);
    slideState.phase = 'end';
    slideState.stepUntil = now + CONFIG.SLIDE_VIKAR_SEC*1000;
    return;
  }

  // default fallback
  showSlideByName('welcomeSlide'); slideState.phase='images'; slideState.stepUntil = now + CONFIG.SLIDE_WELCOME_SEC*1000;
}

/* ===========================
   MORGENSAMLING & G√ÖRDVAGT checks (throttled)
   only check each minute to avoid heavy loops
   =========================== */
let morgensamlingPlayedCount = 0;
const MORG_START_MIN = 8*60 + 20; // 08:20
const MORG_DURATION_MIN = 5; // minutes
const gardvagtTimes = ["09:10","10:50","12:35"];

function checkMorgensamlingNow() {
  const now = new Date();
  const curMin = now.getHours()*60 + now.getMinutes();
  const sound = morgensamlingSound;
  if (curMin >= MORG_START_MIN && curMin < MORG_START_MIN + MORG_DURATION_MIN) {
    morgensamlingBanner.classList.add('active');
    // play once per minute at most
    if (morgensamlingPlayedCount < MORG_DURATION_MIN) {
      try { sound.currentTime = 0; sound.play().catch(()=>{}); } catch(e){}
      morgensamlingPlayedCount = Math.min(MORG_DURATION_MIN, morgensamlingPlayedCount + 1);
    }
  } else {
    morgensamlingBanner.classList.remove('active');
    morgensamlingPlayedCount = 0;
  }
}

let lastGardPlayedMinute = null;
function checkGardvagtNow() {
  const now = new Date();
  const curMin = now.getHours()*60 + now.getMinutes();
  const active = gardvagtTimes.some(t => {
    const [h,m] = t.split(':').map(Number);
    const s = h*60 + m;
    return curMin >= s && curMin < s + 5;
  });
  if (active) {
    gardvagtBanner.classList.add('active');
    const m = now.getMinutes();
    if (m !== lastGardPlayedMinute) {
      try { gardvagtSound.currentTime = 0; gardvagtSound.play().catch(()=>{}); } catch(e){}
      lastGardPlayedMinute = m;
    }
  } else {
    gardvagtBanner.classList.remove('active');
    lastGardPlayedMinute = null;
  }
}

/* ===========================
   initial setup tasks (schedule with the small scheduler)
   =========================== */
schedule('clock', 1000, async ()=> updateDateTime(new Date()), true);
schedule('renderSchedule', 60*1000, async ()=> renderSchedule(), true);
schedule('vikarFetch', CONFIG.VIKAR_FETCH_SEC*1000, async ()=> fetchVikarskema(), true);
schedule('customFetch', CONFIG.CUSTOM_FETCH_SEC*1000, async ()=> fetchCustomImages(), true);
schedule('infoSheet', CONFIG.VIKAR_FETCH_SEC*1000, async ()=> fetchInfoSheet(), true);
schedule('rotateInfo', CONFIG.INFO_ROTATE_SEC*1000, async ()=> rotateInfo(), true);
schedule('weather', CONFIG.WEATHER_FETCH_MIN*60*1000, async ()=> fetchWeather(), true);
schedule('slides', 1000, async ()=> runSlidesOnce(), true); // small tick, actual transitions handled by stepUntil
schedule('morgensamling', 15*1000, async ()=> { checkMorgensamlingNow(); checkGardvagtNow(); }, true);

/* ===========================
   INITIAL LOAD
   =========================== */
(async function init(){
  // perform initial fetches
  try { await fetchVikarskema(); } catch(e){}
  try { await fetchCustomImages(); } catch(e){}
  try { await fetchInfoSheet(); } catch(e){}
  try { await fetchWeather(); } catch(e){}
  renderSchedule();
  rotateInfo();
  updateDateTime(new Date());

  // run a light slideshow loop tick so first background image appears quickly
  runSlidesOnce();

  // Auto reload after long runtime to avoid memory leaks on weak TV browsers
  setTimeout(()=>{ try { location.reload(); } catch(e) { console.warn('reload fail', e); } }, CONFIG.AUTO_RELOAD_HOURS*3600*1000);

  // Friendly hint: audio autoplay may be blocked on some TV browsers.
  // A short attempt to unmute is done, but user interaction might be required.
  try { morgensamlingSound.muted = false; gardvagtSound.muted = false; } catch(e){}
})();

/* ===========================
   Helpers
   =========================== */
function escapeHTML(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function escapeAttr(s){ return String(s).replace(/"/g,'&quot;') }

/* ===========================
   Lightweight mutation observer: ensure bg image removed if hidden (avoid leaks)
   =========================== */
const obs = new MutationObserver(()=> {
  // if bgImg not visible, clear src after a while
  if (!bgImg.classList.contains('show') && bgImg.src) {
    setTimeout(()=> { if (!bgImg.classList.contains('show')) bgImg.src = ''; }, 1500);
  }
});
obs.observe(bgImg, {attributes:true});
// ‚úÖ WATCHDOG ‚Äî restart page if JS ever freezes
let watchdog = 0;
setInterval(() => watchdog++, 1000);

// Every 10s check if counter is still running, if not ‚Üí reload
setInterval(() => {
  const check = watchdog;
  setTimeout(() => {
    if (watchdog === check) {
      console.warn("‚ùó System frozen ‚Üí Auto restarting page...");
      location.reload();
    }
  }, 5000);
}, 10000);

// ‚úÖ Auto refresh every 4 hours (memory cleanup)
setTimeout(() => {
  console.warn("‚ôª Scheduled auto restart (1 hours)");
  location.reload();
}, 1 * 60 * 60 * 1000);

// ‚úÖ Extra safety ‚Äî reload if page becomes hidden/bugged for 30 sec
let hiddenTimer;
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    hiddenTimer = setTimeout(() => {
      console.warn("‚ö† Page hidden too long ‚Üí Restarting");
      location.reload();
    }, 30000);
  } else {
    clearTimeout(hiddenTimer);
  }
});


</script>
</body>
</html>
